% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NestRRR.r
\name{NestRRR}
\alias{NestRRR}
\title{Nested reduced-rank regression with a given rank}
\usage{
NestRRR(Y, X, Ag0 = NULL, Bg0 = NULL, rini, r, rx, ry, jx, jy, p, d, n,
        maxiter = 100, conv = 1e-4, quietly = TRUE,
        method = c("RRR", "RRS")[1], lambda = 0)
}
\arguments{
\item{Y}{the response matrix of dimension n-by-jy*d.}

\item{X}{the design matrix of dimension n-by-jx*p.}

\item{Ag0}{an initial estimator of matrix U. If NULL then generate it
by \code{\link{NestRRRini}}. Default is NULL.}

\item{Bg0}{an initial estimator of matrix V, if NULL then generate it
by \code{\link{NestRRRini}}. Default is NULL.}

\item{rini, r}{rank of the local reduced-rank structure. \code{rini} is used
in \code{\link{NestRRRini}} to get the initial
estimator of U and V.}

\item{rx}{the number of latent predictors.}

\item{ry}{the number of latent responses.}

\item{jx}{the number of basis functions to expand functional predictor.}

\item{jy}{the number of basis functions to expand functional response.}

\item{p}{the number of predictors.}

\item{d}{the number of responses.}

\item{n}{the sample size.}

\item{maxiter}{the maximum iteration number of the
blockwise coordinate descent algorithm. Default is 100.}

\item{conv}{the tolerance level used to control the convergence of the
blockwise coordinate descent algorithm. Default is 1e-4.}

\item{quietly}{a logical value. FALSE: show the
final fitting information (sse and df);
TRUE (default): do not show the results.}

\item{method}{'RRR' (default): no additional ridge penalty; 'RRS': add an
additional ridge penalty.}

\item{lambda}{the tuning parameter to control the amount of ridge
penalization. It is only used when \code{method = 'RRS'}.
Default is 0.}
}
\value{
The function returns a list:
  \item{Ag}{the estimated U.}
  \item{Bg}{the estimated V.}
  \item{Al}{the estimated A.}
  \item{Bl}{the estimated B.}
  \item{C}{the estimated coefficient matrix C.}
  \item{df}{degrees of freedom of the model.}
  \item{sse}{the sum of squared errors.}
  \item{ic}{a vector containing values of BIC, BICP, AIC, GCV.}
  \item{iter}{the number of iterations to converge.}
}
\description{
This function uses a blockwise coordinate descent algorithm
to get the nested reduced-rank regression estimator with a
given \code{(r, rx, ry)}.
}
\details{
The \emph{nested reduced-rank regression (NRRR)} is first motivated to solve
a multivariate functional linear regression problem where both the response and
predictor are multivariate and functional (i.e., \eqn{Y(t)=(y_1(t),...,y_d(t))^T}
and \eqn{X(s)=(x_1(s),...,y_p(s))^T}). To control the complexity of the
problem, NRRR proposes a nested reduced-rank structure on the regression
surface \eqn{C(s,t)}. Specifically, a global dimension reduction makes use of the
correlation within the components of multivariate response and multivariate
predictor. Matrices U (d-by-ry) and V (p-by-rx) provides weights to form latent
functional responses and latent functional predictors. Dimension reduction is achieved
once \eqn{ry \le d} or \eqn{rx \le p}. Then, a local dimension reduction is
conducted by restricting the latent regression surface \eqn{C^*(s,t)} to be of low-rank.
After basis expansion and truncation, also by applying proper rearrangement to
columns and rows of the resulting data matrices and coefficient matrices, we
have the nested reduced-rank problem:
\deqn{ \min_{C} || Y - XC ||_F^2, s.t., C = (I_{jx} \otimes V) BA^T (I_{jy} \otimes U)^T,}
where \eqn{BA^T} is a full-rank decomposition structure to control the local
rank and \eqn{jx, jy} are the number of basis functions. Beyond the functional
setup, this structure can also be applied in multiple scenarios, including
multivariate time series autoregression analysis and tensor-on-tensor regression.
This problem is non-convex and has no explicit solution, thus we use a
blockwise coordinate descent algorithm to find a local solution.
}
\examples{
library(NRRR)
simDat <- nrrr.sim(
  n = 100, ns = 200, nt = 200, r = 5, rx = 3, ry = 3,
  jx = 15, jy = 15, p = 10, d = 6, s2n = 1, rho_X = 0.5,
  rho_E = 0, Sigma = CorrAR
)
fit_init <- with(simDat, NestRRR(
  Y = Yest, X = Xest, Ag0 = NULL, Bg0 = NULL,
  rini = 5, r = 5,
  rx = 3, ry = 3, jx = 15, jy = 15, p = 10, d = 6, n = 100
))
fit_init$Ag
}
\references{
Liu, X., Ma, S., & Chen, K. (2020).
Multivariate Functional Regression via Nested Reduced-Rank Regularization.
arXiv: Methodology.
}
